#!/bin/bash

# TEMPLATE

#=======================================================
# Author: Dave Tompkins, Travis Bartlett, An Le, et. al
# Documentation: An Le (Spring 2018)
#=======================================================

#==========================================================================================================================================
# >> Usage Instructions:
# >> (a) For each of the tests that you intend to have, give it a name, and add it to the test.properties file
# >> (b) For more than one tests of the same kind (e.g. secret), you can separate the names with whitespace
# >> (c) For each of the tests listed in test.properties
# >>   (1) Make a symbolic link to either this template (for regular testing)
# >>       or the assert_template (for testing with invalid input to check that students adequately assert against them)
# >>       in the test/ directory 
# >>       (e.g. "ln -s template secret_test_1" or
# >>             "ln -s assert_template assert_test_1")
# >>   (2) In the input folder, create a subdirectory with the test's name (e.g. secret_test_1)
# >>   (3) In the subdirectory, create a .c, .in, and .expect files that all carry the test name (e.g. secret_test_1.in)
# >>   (4) You can use the .c file to give your own main() function that calls the student's functions
# >>   (5) Or you can use the .in file to give standard input to the student's submssion
# >>   (6) In either case, make sure that you choose the appropriate settings below
# >>       Also, whichever choice you make, it's recommended that you keep it constant across the tests
# >>       Or you would need two separate standard templates (in addition to assert_template)
# >>   (7) Place the expected output in the .expect file
# >> (d) Check the Makefile and make sure that the TEST_INPUT_FILE variable is set to the name of the file that students are submitting
# >> (e) Update the disallowed file to ban certain features of C
# >> (f) For more information, please refer to the ~/bin/checkDisallowed script documentation
# >> (g) If the question was given second-chance, see the section on "duedate" below
# >> (h) Make sure that the provided/ subdirectory contains the most up-to-date files
# >>	 It is highly recommended that you obtain these files directly from the cs136 account, instead of copying from previous terms
# >> (i) Update the canonical solution in sol/
# >> (j) Run ~/marmoset_dynamic/utilities/mkstubs
# >> (k) Upload the correct .test.zip and .sol.zip files in ~/marmoset_dynamic/stubs/ to the appropriate project on Marmoset
#==========================================================================================================================================

#============================
# >> Marmoset Return Codes
#============================

export CORRECT=0
export ERROR=1
export TIMEOUT=2
export WRONG=3

#============================================================
# >> You have to edit the "duedate" file provided 
# >> to correctly specify the ontime submission deadline
# >> if this question was granted second-chance
#
# >> This part of the script will warn students to submit
# >> to the extended project instead of the original
# >> if the original ontime submission deadline has passed
#============================================================

if [ -f duedate ]
then
  ./duedate
  if [ $? -eq 1 ]; then
    exit $ERROR
  fi
fi

#====================================================
# >> Important Variables
#====================================================

TESTNAME=`basename $0`
TESTDIR=/tmp/$$.dir
TIME=60 #Number of seconds until the Seashell-cli declares timeout
	#All efficiency tests should take less than 60s to complete with the optimal solution
	#If this is changed, contact CSCF to change the error message on Marmoset as well
	#As it is, the message will say that the submission took more than 60s to complete
	#which would be inaccurate if this variable is not actually set to 60
BIG_TIME="240s" #Number of seconds until the system kills Seashell-cli itself (e.g. if Seashell-cli freezes)
		#As mentioned before, no single test should take 60s to complete, let alone 240s
		#Should not be changed
		#See below for more details

#====================================================
# >> File Student is Submitting (CHANGE)
#====================================================

SUBMISSION="REPLACE_ME"

#========================================================================================
# >> Execution File
#
# >> OPTION (1)
# >> Use this option if you want to use .in files to give input
# >> For this case, you do not need the .c files inside the subdirectories of input/
#========================================================================================

MAINFILE=${SUBMISSION}

#========================================================================================================
# >> Execution File
#
# >> OPTION (2)
# >> Use this option if you want to use custom main() functions to call student's functions
# >> Make sure that in each of the subdirectories of input/,
# >> every file (including the .c file) matches the name of that subdirectory
# >> Set to ${TESTNAME}.c if you want to have a unique runner file per test
# >> Or to a specific name (e.g. robot-io.c) if all tests using this template share the same runner file
#========================================================================================================

#MAINFILE=${TESTNAME}.c

#==============================================================
# >> Copying Relevant Files to a Temporary Testing Directory
#==============================================================

mkdir $TESTDIR

if  [ -d common ]; then
  /bin/cp common/* $TESTDIR 2>/dev/null
fi;
/bin/cp disallowed $TESTDIR 2>/dev/null
/bin/cp input/${TESTNAME}/* $TESTDIR
/bin/cp *.{c,h,o,ll,rkt} $TESTDIR 2>/dev/null
/bin/cp provided/*.{h,o,c,ll,rkt} $TESTDIR 2>/dev/null
/bin/cp optimal $TESTDIR/$$time
/bin/cp marmotime.sh $TESTDIR/
/bin/cp base_chrono $TESTDIR/
/bin/cp chrono $TESTDIR/

/bin/cp $SUBMISSION $TESTDIR

cd $TESTDIR

#=============================================
# >> Removing the Student's main() Function
# >> Do this if you chose Option (2) above
#=============================================

#sed -ri 's/(int\s+)main(\s*\((void)?\)\s*\{)/\1daveIsAdequate\2 return 0;/g' $SUBMISSION

#=================================
# >> Integrity Statement Check
#=================================

if egrep "ERROR_NO_INTEGRITY_STATEMENT|ERROR_NO_NAME|ERROR_NO_LOGIN" ${SUBMISSION} >/dev/null; then
  echo "You have not modified your integrity statement."
  CODE=$ERROR
  cd /u/cs136t
  rm -r $TESTDIR
  exit $CODE
fi

#==================================================================================
# >> Applying the Test Cases
# >> Checking the Seashell-Cli Return Values
# >> Checking for Timeout
#==================================================================================

  #----------------------------------------------------------------------------------
  # >> Note: the timeout wrapper call is usually not necessary
  # >> i.e. if you remove it, nothing should change in most cases
  # >> Seashell-cli should terminate the testing process after $TIME seconds
  # >> The timeout script is only there to forcefully end Seashell-cli itself
  # >> if something goes horribly wrong and the script takes more than $BIG_TIME
  # >> to terminate (e.g. if Seashell-cli freezes in the middle of execution)
  # >> Also, the '.' in the Seashell-cli script call represents the current directory,
  # >> which is a required argument for the script to run
  # >> Fun fact: the return code RET will be set to 124 if the test runs on for more
  # >> than $BIG_TIME, which will be categorized by this script as an "unknown error"
  #----------------------------------------------------------------------------------

/usr/bin/timeout $BIG_TIME /u/cs136t/bin/seashell-cli marmtest -t $TIME . $MAINFILE $TESTNAME out err 1>cliout 2>clierr
RET=$?
common_error=0

if [ $RET -eq 10 ] ; then
  
  if [ -f err_v ]; then
    rm err_v
  fi

  grep "variable length array" err > err_v

  if [ -s err_v ]; then
    echo "ERROR: Variable length array detected."
    ((common_error++))
    CODE=$ERROR
  fi

  if [ $common_error -eq 0 ]; then
    echo "ERROR:"
    echo ""
    cat err
    CODE=$ERROR
  fi

elif [ $RET -eq 20 ]; then
  #----------------------------------------------------------------------------------
  # >> This is mainly triggered when the program exits with a non-zero exit code
  # >> , causes a stack/buffer overflow, or has a memory leak
  # >> Note: this is what is usually triggered by the efficiency tests
  # >> For the efficiency tests:
  # >> Our exit(1) statement should always be accompanied by a message to
  # >> stderr containing the term "timeout", and should only be activated
  # >> if the student submission did not complete executive in time
  # >> This can be check using the <time.h> library functions
  # >> See the provided sample source files for more details
  #---------------------------------------------------------------------------------- 
  if [ -f err_t ]; then
    rm err_t
  fi
  if [ -f err_o ]; then
    rm err_o
  fi
  if [ -f err_b ]; then
    rm err_b
  fi
  if [ -f err_m ]; then
    rm err_m
  fi
  if [ -f err_h ]; then
    rm err_h
  fi
  if [ -f err_d ]; then
    rm err_d
  fi
  if [ -f err_a ]; then
    rm err_a
  fi
  if [ -f err_p ]; then
    rm err_p
  fi
  if [ -f err_s ]; then
    rm err_s
  fi

  grep "timeout" err > err_t
  grep "stack-overflow" err > err_o
  grep "buffer-overflow" err > err_b
  grep "memory leak" err > err_m 
  grep "heap-use-after-free" err > err_h
  grep "double-free" err > err_d
  grep "failed to allocate" err > err_a
  grep "FPE" err > err_p
  grep "SEGV" err > err_s
  
  if [ -s err_t ]; then
    echo "Your program did not complete execution within the time limit."
    ((common_error++))
    CODE=$WRONG
  fi
  if [ -s err_o ]; then
    echo "ERROR: Stack overflow detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_b ]; then
    echo "ERROR: Buffer overflow detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_m ]; then
    echo "ERROR: Memory leak detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_h ]; then
    echo "ERROR: Heap use after free detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_d ]; then
    echo "ERROR: Double free detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_a ]; then
    echo "ERROR: Failed to allocate requested memory."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_p ]; then
    echo "ERROR: Floating point exception detected."
    ((common_error++))
    CODE=$ERROR
  fi
  if [ -s err_s ]; then
    echo "ERROR: Segmentation fault detected."
    ((common_error++))
    CODE=$ERROR
  fi

  if ! [ -s err ]; then
    echo "Your program terminated with a non-zero exit code."
    CODE=$ERROR
  elif [ $common_error -eq 0 ]; then
    echo "ERROR:"
    echo ""
    cat err
    CODE=$ERROR
  fi

  rm err_t
  rm err_o
  rm err_b
  rm err_m
  rm err_h
  rm err_d
  rm err_a
  rm err_p
  rm err_s

elif [ $RET -eq 30 ]; then
  echo "Your output:                     	                    Expected output:"
  diff -y out ${TESTNAME}.expect
  CODE=$WRONG
elif [ $RET -eq 40 ]; then  
  M_RET=0
  
  SOLUTION="$$time"
  INPUT="${TESTNAME}.in"
  LENIENCY=20

  if [ "${MAINFILE}" == "${SUBMISSION}" ]; then
    ./marmotime.sh -e ${SUBMISSION} ${SOLUTION} ${INPUT} ${LENIENCY}
    M_RET=$?
  else
    ./marmotime.sh ${MAINFILE} ${SUBMISSION} ${SOLUTION} ${INPUT} ${LENIENCY}
    M_RET=$?
  fi
  if [ $M_RET -eq 0 ]; then
    echo "Test passed."
    CODE=$CORRECT
  else
    echo "Your solution is not efficient enough."
    CODE=$WRONG
  fi
elif [ $RET -eq 50 ]; then
  #-------------------------------------------------------------------------------------------------
  # >> This is when the student's submission runs on for more than $TIME seconds
  # >> Note: this is NOT what is usually triggered by the efficiency tests
  # >> Usually for those you would want to restrict the time more (to around 3-5 seconds) 
  # >> See the section above for more details
  # >> Think of this as a hard, omnipresent time limit for Marmoset
  # >> Note: the $WRONG exit code is used to preserve consistency across the two "types" of timeouts
  #--------------------------------------------------------------------------------------------------
  echo "Your program did not complete execution within the time limit."
  CODE=$WRONG
elif [ $RET -eq 21 ]; then
  sed 's/^.*\(Assertion.*\)$/\1/' err > err_f
  cat err_f
  CODE=$WRONG
else
  echo "Unknown error, please send a ticket to the request system on the CS136 website."
  cat cliout
  echo ''
  cat clierr
  echo ''
  cat err
  CODE=$ERROR
fi

#=========================================================
# >> Deleting Temporary Testing Directory
# >> Returning Appropriate Exit Code
#=========================================================

cd /u/cs136t
rm -r $TESTDIR
exit $CODE
